-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\book_example\soft_demodulation_src_Soft_Demodulation.vhd
-- Created: 2022-11-22 20:57:46
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.25e-08
-- Target subsystem base rate: 1.25e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1.25e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- m_axis_tvalid                 ce_out        1.25e-08
-- m_axis_tdata                  ce_out        1.25e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: soft_demodulation_src_Soft_Demodulation
-- Source Path: book_example/Soft Demodulation
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.soft_demodulation_src_Soft_Demodulation_pkg.ALL;

ENTITY soft_demodulation_src_Soft_Demodulation IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        aximm_llr_scale                   :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En12
        s_axis_tvalid                     :   IN    std_logic;
        s_axis_tdata                      :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        ce_out                            :   OUT   std_logic;
        m_axis_tvalid                     :   OUT   std_logic;
        m_axis_tdata                      :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END soft_demodulation_src_Soft_Demodulation;


ARCHITECTURE rtl OF soft_demodulation_src_Soft_Demodulation IS

  -- Component Declarations
  COMPONENT soft_demodulation_src_real
    PORT( u                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En11
          b3                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En11
          b2                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En11
          );
  END COMPONENT;

  COMPONENT soft_demodulation_src_imag
    PORT( u                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En11
          b1                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En11
          b0                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En11
          );
  END COMPONENT;

  COMPONENT soft_demodulation_src_symmetric_saturation
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          soft_bits                       :   IN    std_logic_vector(5 DOWNTO 0);  -- sfix6_En2
          u                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT soft_demodulation_src_symmetric_saturation1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          soft_bits                       :   IN    std_logic_vector(5 DOWNTO 0);  -- sfix6_En2
          u                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT soft_demodulation_src_symmetric_saturation2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          soft_bits                       :   IN    std_logic_vector(5 DOWNTO 0);  -- sfix6_En2
          u                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT soft_demodulation_src_symmetric_saturation3
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          soft_bits                       :   IN    std_logic_vector(5 DOWNTO 0);  -- sfix6_En2
          u                               :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : soft_demodulation_src_real
    USE ENTITY work.soft_demodulation_src_real(rtl);

  FOR ALL : soft_demodulation_src_imag
    USE ENTITY work.soft_demodulation_src_imag(rtl);

  FOR ALL : soft_demodulation_src_symmetric_saturation
    USE ENTITY work.soft_demodulation_src_symmetric_saturation(rtl);

  FOR ALL : soft_demodulation_src_symmetric_saturation1
    USE ENTITY work.soft_demodulation_src_symmetric_saturation1(rtl);

  FOR ALL : soft_demodulation_src_symmetric_saturation2
    USE ENTITY work.soft_demodulation_src_symmetric_saturation2(rtl);

  FOR ALL : soft_demodulation_src_symmetric_saturation3
    USE ENTITY work.soft_demodulation_src_symmetric_saturation3(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL s_axis_tvalid_1                  : std_logic;
  SIGNAL s_axis_tdata_unsigned            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL in_2_pipe_reg                    : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL s_axis_tdata_1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion_out1        : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL b3                               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL b2                               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL b3_signed                        : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL aximm_llr_scale_unsigned         : unsigned(31 DOWNTO 0);  -- ufix32_En12
  SIGNAL in_0_pipe_reg                    : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL aximm_llr_scale_1                : unsigned(31 DOWNTO 0);  -- ufix32_En12
  SIGNAL Product_cast                     : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL Product_mul_temp                 : signed(48 DOWNTO 0);  -- sfix49_En23
  SIGNAL Product_cast_1                   : signed(47 DOWNTO 0);  -- sfix48_En23
  SIGNAL Product_out1                     : signed(5 DOWNTO 0);  -- sfix6_En2
  SIGNAL b2_signed                        : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL Product1_cast                    : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL Product1_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En23
  SIGNAL Product1_cast_1                  : signed(47 DOWNTO 0);  -- sfix48_En23
  SIGNAL Product1_out1                    : signed(5 DOWNTO 0);  -- sfix6_En2
  SIGNAL Bit_Slice2_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion1_out1       : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL b1                               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL b0                               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL b1_signed                        : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL Product2_cast                    : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL Product2_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En23
  SIGNAL Product2_cast_1                  : signed(47 DOWNTO 0);  -- sfix48_En23
  SIGNAL Product2_out1                    : signed(5 DOWNTO 0);  -- sfix6_En2
  SIGNAL b0_signed                        : signed(15 DOWNTO 0);  -- sfix16_En11
  SIGNAL Product3_cast                    : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL Product3_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En23
  SIGNAL Product3_cast_1                  : signed(47 DOWNTO 0);  -- sfix48_En23
  SIGNAL Product3_out1                    : signed(5 DOWNTO 0);  -- sfix6_En2
  SIGNAL y                                : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y_unsigned                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL y_1                              : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y_unsigned_1                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL y_2                              : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y_unsigned_2                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL y_3                              : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL y_unsigned_3                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL out_1_pipe_reg                   : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL Bit_Concat_out1_1                : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  u_real : soft_demodulation_src_real
    PORT MAP( u => std_logic_vector(Data_Type_Conversion_out1),  -- sfix16_En11
              b3 => b3,  -- sfix16_En11
              b2 => b2  -- sfix16_En11
              );

  u_imag : soft_demodulation_src_imag
    PORT MAP( u => std_logic_vector(Data_Type_Conversion1_out1),  -- sfix16_En11
              b1 => b1,  -- sfix16_En11
              b0 => b0  -- sfix16_En11
              );

  u_symmetric_saturation : soft_demodulation_src_symmetric_saturation
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              soft_bits => std_logic_vector(Product_out1),  -- sfix6_En2
              u => y  -- uint8
              );

  u_symmetric_saturation1 : soft_demodulation_src_symmetric_saturation1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              soft_bits => std_logic_vector(Product1_out1),  -- sfix6_En2
              u => y_1  -- uint8
              );

  u_symmetric_saturation2 : soft_demodulation_src_symmetric_saturation2
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              soft_bits => std_logic_vector(Product2_out1),  -- sfix6_En2
              u => y_2  -- uint8
              );

  u_symmetric_saturation3 : soft_demodulation_src_symmetric_saturation3
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              soft_bits => std_logic_vector(Product3_out1),  -- sfix6_En2
              u => y_3  -- uint8
              );

  enb <= clk_enable;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= s_axis_tvalid;
        delayMatch_reg(1 TO 5) <= delayMatch_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  s_axis_tvalid_1 <= delayMatch_reg(5);

  s_axis_tdata_unsigned <= unsigned(s_axis_tdata);

  in_2_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_2_pipe_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_2_pipe_reg(0) <= s_axis_tdata_unsigned;
        in_2_pipe_reg(1) <= in_2_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;

  s_axis_tdata_1 <= in_2_pipe_reg(1);

  Bit_Slice1_out1 <= s_axis_tdata_1(15 DOWNTO 0);

  Data_Type_Conversion_out1 <= signed(Bit_Slice1_out1);

  b3_signed <= signed(b3);

  aximm_llr_scale_unsigned <= unsigned(aximm_llr_scale);

  in_0_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_0_pipe_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        in_0_pipe_reg(0) <= aximm_llr_scale_unsigned;
        in_0_pipe_reg(1) <= in_0_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;

  aximm_llr_scale_1 <= in_0_pipe_reg(1);

  Product_cast <= signed(resize(aximm_llr_scale_1, 33));
  Product_mul_temp <= b3_signed * Product_cast;
  Product_cast_1 <= Product_mul_temp(47 DOWNTO 0);
  
  Product_out1 <= "011111" WHEN (Product_cast_1(47) = '0') AND (Product_cast_1(46 DOWNTO 26) /= "000000000000000000000") ELSE
      "100000" WHEN (Product_cast_1(47) = '1') AND (Product_cast_1(46 DOWNTO 26) /= "111111111111111111111") ELSE
      Product_cast_1(26 DOWNTO 21);

  b2_signed <= signed(b2);

  Product1_cast <= signed(resize(aximm_llr_scale_1, 33));
  Product1_mul_temp <= b2_signed * Product1_cast;
  Product1_cast_1 <= Product1_mul_temp(47 DOWNTO 0);
  
  Product1_out1 <= "011111" WHEN (Product1_cast_1(47) = '0') AND (Product1_cast_1(46 DOWNTO 26) /= "000000000000000000000") ELSE
      "100000" WHEN (Product1_cast_1(47) = '1') AND (Product1_cast_1(46 DOWNTO 26) /= "111111111111111111111") ELSE
      Product1_cast_1(26 DOWNTO 21);

  Bit_Slice2_out1 <= s_axis_tdata_1(31 DOWNTO 16);

  Data_Type_Conversion1_out1 <= signed(Bit_Slice2_out1);

  b1_signed <= signed(b1);

  Product2_cast <= signed(resize(aximm_llr_scale_1, 33));
  Product2_mul_temp <= b1_signed * Product2_cast;
  Product2_cast_1 <= Product2_mul_temp(47 DOWNTO 0);
  
  Product2_out1 <= "011111" WHEN (Product2_cast_1(47) = '0') AND (Product2_cast_1(46 DOWNTO 26) /= "000000000000000000000") ELSE
      "100000" WHEN (Product2_cast_1(47) = '1') AND (Product2_cast_1(46 DOWNTO 26) /= "111111111111111111111") ELSE
      Product2_cast_1(26 DOWNTO 21);

  b0_signed <= signed(b0);

  Product3_cast <= signed(resize(aximm_llr_scale_1, 33));
  Product3_mul_temp <= b0_signed * Product3_cast;
  Product3_cast_1 <= Product3_mul_temp(47 DOWNTO 0);
  
  Product3_out1 <= "011111" WHEN (Product3_cast_1(47) = '0') AND (Product3_cast_1(46 DOWNTO 26) /= "000000000000000000000") ELSE
      "100000" WHEN (Product3_cast_1(47) = '1') AND (Product3_cast_1(46 DOWNTO 26) /= "111111111111111111111") ELSE
      Product3_cast_1(26 DOWNTO 21);

  y_unsigned <= unsigned(y);

  y_unsigned_1 <= unsigned(y_1);

  y_unsigned_2 <= unsigned(y_2);

  y_unsigned_3 <= unsigned(y_3);

  Bit_Concat_out1 <= y_unsigned & y_unsigned_1 & y_unsigned_2 & y_unsigned_3;

  out_1_pipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      out_1_pipe_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        out_1_pipe_reg(0) <= Bit_Concat_out1;
        out_1_pipe_reg(1) <= out_1_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_1_pipe_process;

  Bit_Concat_out1_1 <= out_1_pipe_reg(1);

  m_axis_tdata <= std_logic_vector(Bit_Concat_out1_1);

  ce_out <= clk_enable;

  m_axis_tvalid <= s_axis_tvalid_1;

END rtl;

